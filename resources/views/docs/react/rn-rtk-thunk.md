# Redux Toolkit - Thunk (WIP)

- [What is Thunk?](#what-is-thunk)
- [Asynchronous actions](#asynchronous-actions)
  - [Define an asynchronous action with `createAsyncThunk`](#define-an-asynchronous-action-with-createasyncthunk)

## What is Thunk?

Beside being a dull, heavy sound, such as that made by an object falling to the ground,
'thunk' is a term used in programming to describe a function that wraps an expression to
delay its evaluation.

In the context of Redux, a thunk is a function that can be dispatched to the store that
can contain side effects, asynchronous requests, and other logic.

Redux Toolkit provides a `createAsyncThunk` function that allows you to define a thunk
that dispatches pending, fulfilled, and rejected actions based on the promise it
returns.


## Asynchronous actions

Asynchronous actions are actions that are dispatched to the store and contain side
effects, such as API requests, that are not immediately resolved.

### Define an asynchronous action with `createAsyncThunk`

To define an asynchronous action, you can use the `createAsyncThunk` function from Redux
Toolkit. This function takes two arguments: a string that represents the action type and
an asynchronous function that returns a promise.

This is an abstract example of how you can define an asynchronous action with
`createAsyncThunk`, for a concrete example see the ....... example.


**Things to know:**

- When working with asynchronous functions, you always define the action first using
  `createAsyncThunk`, and then you define the reducers.
- The way you define a reducer for an asynchronous function is different because it
  doesn’t go in the `reducers` object. It actually goes at the bottom in something that
  we call `extraReducers`.
- You don’t need to worry too much about the `builder`, it’s just a tool that allows you
  to essentially add cases to the reducers.
- Through the `builder` object, you can define how the state should be updated based on
  the different states of the promise (pending, fulfilled, rejected).
- The naming of actions and reducers is automatically generated by Redux Toolkit. You
  only need to define the action name for asynchronous functions.



```js
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

const initialState = {};

// Define the slice, and add the asynchronous actions to the `extraReducers` object
const featureSlice = createSlice({
    name: 'feature',
    initialState,
    reducers: {},
    extraReducers: (builder) => {
        builder
            .addCase(someAction.pending, (state) => {
                // Handle the pending state when the promise is pending
            })
            .addCase(someAction.fulfilled, (state, action) => {
                // Handle the fulfilled state when the promise is resolved
            })
            .addCase(someAction.rejected, (state) => {
                // Handle the rejected state when the promise is rejected
            });
     }
});

export const someAction = createAsyncThunk(
    'feature/someAction',
    async () => {
        // Perform an asynchronous operation here
        // and return the result as a promise
    }
);

export const { action1, action2 } = featureSlice.actions;
export default featureSlice.reducer;
```



<question>Why do we use extraReducers for asynchronous functions?</question>

<answer>When working with asynchronous functions, you need to handle different states
such as pending, fulfilled, and rejected. The `extraReducers` object allows you to
define reducers for these states separately from the synchronous reducers. This makes it
easier to manage the different states and update the state accordingly.</answer>

```html +parse
<x-alert type="info">
Conceptually, the <code>extraReducers</code> works the same way as the <code>reducers</code> object, but it handles asynchronous actions using the <code>builder</code> object.
</x-alert>
```

