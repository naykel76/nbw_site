# Claude Instruction### Documentation Standards

#### Content Structure
- Use **clear, descriptive headings** with proper hierarchy (H1 > H2 > H3)
- Use **sentence case** for titles and headings (e.g., "Create a navigation file" not "Create A Navigation File")
- **Keep headings simple and direct** - avoid verbose, overcomplicated titles (e.g., "Creating the JSON file" not "Creating the Configuration File")
- Start documents with a main H1 title
- Include **table of contents** for longer documents using manual anchor links Technology Stack & Packages

### Core Stack
- **Framework**: Laravel 12 (PHP 8.2+)
- **Frontend**: Livewire 3, Blade templates, Alpine.js
- **Testing**: Pest PHP
- **Code Quality**: Laravel Pint (PHP CS Fixer)
- **Database**: MySQL/PostgreSQL (standard Laravel setup)
- **Build Tools**: Vite

### Custom Packages
- `naykel/authit`: Authentication package
- `naykel/contactit`: Contact forms
- `naykel/gotime`: Date/time utilities
- `naykel/payit`: Payment processing
- `naykel/postit`: Post/content management
- `naykel/devit`: Development utilities

## Documentation Standards

### Content Structure
- Use **clear, descriptive headings** with proper hierarchy (H1 > H2 > H3)
- Use **sentence case** for titles and headings (e.g., "Create a navigation file" not "Create A Navigation File")
- Start documents with a main H1 title
- Include **table of contents** for longer documents using manual anchor links

### Code Formatting
- Use **Torchlight syntax highlighting** with `+torchlight-<language>` for code blocks
- Support for languages: `php`, `html`, `css`, `scss`, `javascript`, `json`, `bash`
- Use **inline code formatting** with backticks for variables, methods, classes, and file names
- Use **fenced code blocks** for multi-line examples

### Special Elements
- Use **custom alert components** for important information:
  ```html +parse
  <x-gt-alert type="info">
  Informational content here
  </x-gt-alert>
  ```
  - Alert types: `info`, `warning`, `danger`, `success`
- Use **question format** for FAQ sections:
  ```markdown
  ### <question>How do I do something?</question>
  ```
- Do not Use **horizontal rules** (`---`) to separate major sections

### Documentation Best Practices
- **Be concise but thorough** - avoid unnecessary verbosity
- **Use examples** to illustrate concepts, especially for technical content
- **Include context** - explain why something is done, not just how
- **Keep language professional** without excessive exclamations or informalities
- **Update status indicators** like "**TO BE REVIEWED**" for work-in-progress sections
- Use **bold formatting** for emphasis on key terms and concepts
- Use **consistent bullet points** with proper nesting (2-4 spaces for sub-items)
- Use **descriptive link text** rather than "click here"
- Use **proper markdown tables** with alignment when displaying tabular data
- **Use Australian English spelling** (e.g., "customise" not "customize", "colour" not "color", "behaviour" not "behavior")
- **Wrap markdown text to 80 characters per line** for better readability and version control (applies to regular text only - do not wrap code blocks, HTML, JSON, or other structured content)

## Code Standards & Best Practices

### General Principles
- Follow **PSR-12** coding style and **SOLID principles**
- Follow **DRY** (Don't Repeat Yourself) and **KISS** (Keep It Simple, Stupid) principles
- Prefer short, expressive, and readable code over cleverness
- Use **meaningful, descriptive variable, function, class, and file names**
- Apply proper PHPDoc blocks for classes, methods, and complex logic
- Organize code into small, reusable functions or classes with single responsibility
- Avoid magic numbers or hard-coded strings; use constants or config files

### PHP 8.2+ Modern Features
- Use **readonly properties** to enforce immutability where applicable
- Use **Enums** instead of string or integer constants
- Utilize **First-class callable syntax** for callbacks
- Leverage **Constructor Property Promotion**
- Use **Union Types**, **Intersection Types**, and **true/false return types** for strict typing
- Apply **Static Return Type** where needed
- Use the **Nullsafe Operator (?->)** for optional chaining
- Adopt **final classes** where extension is not intended
- Use **Named Arguments** for improved clarity when calling functions with multiple parameters
- Use strict typing (`declare(strict_types=1);`) for new files
- Always use type hints for parameters and return types

### Security & Validation
- Never trust user input; always validate and sanitize inputs
- Use prepared statements via Eloquent or Query Builder to prevent SQL injection
- Use Laravel's built-in CSRF, XSS, and validation mechanisms
- Store sensitive information in `.env`, never hard-code secrets
- Apply proper authorization checks using Policies or Gates
- Follow principle of least privilege for users, roles, and permissions
- Use mass assignment protection with `$fillable` or `$guarded`

### Performance & Optimization
- Eager load relationships to avoid N+1 queries
- Use caching with Laravel's Cache system for frequently accessed data
- Paginate large datasets using `paginate()` instead of `get()`
- Queue long-running tasks using Laravel Queues
- Optimize database indexes for common queries

## Laravel-Specific Guidelines

### Project Structure
Follow the official Laravel project structure:
- `app/Http/Controllers` - Controllers (thin, use dependency injection)
- `app/Models` - Eloquent models
- `app/Http/Requests` - Form request validation
- `app/Http/Resources` - API resource responses
- `app/Enums` - Enums
- `app/Services` - Business logic
- `app/Data` - Data Transfer Objects (DTOs)
- `app/Actions` - Single-responsibility action classes
- `app/Policies` - Authorization logic

### Naming Conventions
- **Models**: PascalCase, singular (e.g., `User`, `ScheduledEvent`)
- **Controllers**: PascalCase with Controller suffix
- **Migrations**: snake_case with descriptive names
- **Routes**: kebab-case URLs
- **Tables**: snake_case, plural

### Controllers
- Keep controllers thin
- Use dependency injection
- Use Form Requests for validation
- Return typed responses (e.g., `JsonResponse`)
- Use Resource classes for API responses

### Eloquent & Database
- Use **Eloquent Models** with proper `$fillable` or `$guarded` attributes
- Utilize **casts** for date, boolean, JSON, and custom data types (use `DateCast::class`)
- Apply **accessors & mutators** for attribute transformation
- Avoid direct raw SQL unless absolutely necessary; prefer Eloquent or Query Builder
- Always use migrations for schema changes
- Include proper constraints (foreign keys, unique indexes, etc.)
- Use descriptive migration names
- Use proper foreign key relationships

### Livewire 3 Conventions
- Use Livewire 3 syntax and patterns
- Component classes in `app/Livewire/` with organized subdirectories
- Form objects in `app/Livewire/Forms/` (e.g., `ScheduledEventFormObject`)
- Follow the pattern: `AdminScheduledEventsDashboard` for admin components
- Use protected properties with proper visibility
- Implement proper validation in form objects

### Business Logic
Business logic should reside in:
- Service classes
- Action classes
- Event listeners or Jobs for asynchronous tasks

## Testing & Quality Assurance

### Testing Standards
- Use **Pest** for testing (not PHPUnit syntax) with clear, human-readable test names
- Use **factories** for test data setup
- Include feature tests for user-facing functionality
- Include unit tests for business logic, services, and helper classes
- Use descriptive test names that explain the scenario
- Prefer `it` syntax for Pest tests

### Code Quality
- Use Laravel Pint for code formatting (`composer format`)
- Generate strictly typed, modern PHP code using latest language features
- Suggest proper class placement based on Laravel directory structure
- Suggest tests alongside new features where applicable
- Default to immutability, dependency injection, and encapsulation best practices

## Development Patterns

### Common Task Patterns
- **Livewire Components**: Always include proper validation and error handling
- **API Endpoints**: Return consistent JSON responses with proper HTTP status codes
- **Database Queries**: Use Eloquent relationships and avoid N+1 problems
- **Form Handling**: Use Livewire form objects for complex forms
- **File Operations**: Use Laravel's Storage facade for file management

### When Writing New Code
1. Use proper validation in Livewire forms
2. Follow Laravel best practices for database queries and relationships
3. Write descriptive variable and method names
4. Use dependency injection where appropriate
5. Include proper docblocks for complex methods

### When Suggesting Improvements
1. Prefer Eloquent relationships over raw queries
2. Use resource controllers for RESTful operations
3. Implement proper error handling and validation
4. Consider performance implications of queries
5. Suggest caching strategies where appropriate

## Claude Behavior Preferences

- Avoid legacy or deprecated Laravel patterns (facade overuse, logic-heavy views, etc.)
- Avoid starting responses with "Sure!", "You're right!" or similar phrases; be direct and concise
- When writing text that'll be visible to users, use **clear, professional language** without unnecessary exclamations or informalities
- Use sentence case for titles and headings
- Prioritize readable, clean, maintainable code over cleverness
