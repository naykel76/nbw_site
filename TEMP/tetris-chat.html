<!DOCTYPE html>
<html>

<head>
    <title>Tetris Game</title>
    <style>
        canvas {
            border: 2px solid black;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <canvas id="board" width="300" height="600"></canvas>
    <script src="tetris.js"></script>

    <script>
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const COLORS = ['cyan', 'blue', 'orange', 'yellow', 'green', 'purple', 'red'];
        const SHAPES = [
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]],
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]],
            [[4, 4], [4, 4]],
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]],
            [[0, 6, 0], [6, 6, 6], [0, 0, 0]],
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]]
        ];

        const KEY = {
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40
        };
        Object.freeze(KEY);

        class Piece {
            constructor(ctx) {
                this.ctx = ctx;

                const typeId = this.randomizeTetrominoType(COLORS.length);
                this.shape = SHAPES[typeId];
                this.color = COLORS[typeId];

                // Starting position.
                this.x = 3;
                this.y = 0;
            }

            draw() {
                this.ctx.fillStyle = this.color;
                this.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value > 0) {
                            this.ctx.fillRect(this.x + x, this.y + y, 1, 1);
                        }
                    });
                });
            }

            move(p) {
                this.x = p.x;
                this.y = p.y;
                this.shape = p.shape;
            }

            randomizeTetrominoType(noOfTypes) {
                return Math.floor(Math.random() * noOfTypes);
            }
        }

        class Board {
            constructor(ctx) {
                this.ctx = ctx;
                this.grid = this.getEmptyBoard();
                this.piece = new Piece(ctx);
            }

            // Get matrix filled with zeros.
            getEmptyBoard() {
                return Array.from(
                    { length: ROWS }, () => Array(COLS).fill(0)
                );
            }

            rotate(piece) {
                // Clone with JSON
                let p = JSON.parse(JSON.stringify(piece));

                // Transpose matrix, p is the Piece
                for (let y = 0; y < p.shape.length; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [p.shape[x][y], p.shape[y][x]] =
                            [p.shape[y][x], p.shape[x][y]];
                    }
                }

                // Reverse the order of the columns.
                p.shape.forEach(row => row.reverse());

                return p;
            }

            valid(p) {
                return p.shape.every((row, dy) => {
                    return row.every((value, dx) => {
                        let x = p.x + dx;
                        let y = p.y + dy;
                        return value === 0 || (this.isInsideWalls(x, y) && this.isNotOccupied(x, y));
                    });
                });
            }

            isNotOccupied(x, y) {
                return this.grid[y] && this.grid[y][x] === 0;
            }

            isInsideWalls(x, y) {
                return (
                    x >= 0 && // Left wall
                    x < COLS && // Right wall
                    y < ROWS // Bottom wall
                );
            }

            drop() {
                let p = TetrisGame.moves[KEY.DOWN](this.piece);

                if (this.valid(p)) {
                    this.piece.move(p);
                } else {
                    this.freeze();
                    this.clearLines();
                    if (this.piece.y === 0) {
                        // Game over
                        return false;
                    }
                    this.piece = new Piece(this.ctx);
                }
                return true;
            }

            freeze() {
                this.piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value > 0) {
                            this.grid[y + this.piece.y][x + this.piece.x] = value;
                        }
                    });
                });
            }

            draw() {
                this.grid.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value > 0) {
                            this.ctx.fillStyle = COLORS[value - 1];
                            this.ctx.fillRect(x, y, 1, 1);
                        }
                    });
                });
            }

            clearLines() {
                this.grid.forEach((row, y) => {
                    // If every value is greater than zero then we have a full row.
                    if (row.every(value => value > 0)) {
                        // Remove the row.
                        this.grid.splice(y, 1);

                        // Add zero-filled row at the top.
                        this.grid.unshift(Array(COLS).fill(0));
                    }
                });
            }
        }

        class TetrisGame {
            constructor() {
                this.canvas = document.getElementById('board');
                this.ctx = this.canvas.getContext('2d');

                // Calculate size of canvas from constants.
                this.ctx.canvas.width = COLS * BLOCK_SIZE;
                this.ctx.canvas.height = ROWS * BLOCK_SIZE;

                // Scale blocks
                this.ctx.scale(BLOCK_SIZE, BLOCK_SIZE);

                this.board = new Board(this.ctx);
                this.requestId = null;

                this.time = { start: 0, elapsed: 0, level: 1000 };
            }

            static moves = {
                [KEY.LEFT]: (p) => ({ ...p, x: p.x - 1 }),
                [KEY.RIGHT]: (p) => ({ ...p, x: p.x + 1 }),
                [KEY.DOWN]: (p) => ({ ...p, y: p.y + 1 }),
                [KEY.UP]: (p) => this.board.rotate(p),
                [KEY.SPACE]: (p) => ({ ...p, y: p.y + 1 }),
            };

            handleKeyPress(event) {
                // Stop the event from bubbling.
                event.preventDefault();


    </script>
</body>

</html>
